class PeerWebRTC{constructor(e=!1,t,n={}){this.peer=new RTCPeerConnection(n),this.stream=t,this.initiator=e,this.events={onSignal:()=>{console.warn("onSignal called without a callback at "+(new Date).toISOString())},onConnect:()=>{},onDisconnect:()=>{},onIceCandidate:()=>{},onData:()=>{},onStream:()=>{}},this.peer.ontrack=async e=>{0<e.streams.length&&await this.events.onStream(e.streams[0])},this.initialize(),this.peer.onconnectionstatechange=e=>{switch(this.peer.connectionState){case"connected":break;case"disconnected":this.events.onDisconnect()}},this.peer.onicecandidate=e=>{e.candidate&&this.events.onIceCandidate(e.candidate)},this.peer.ondatachannel=e=>{e.channel.onmessage=e=>{this.events.onData(e.data)}}}async initialize(){var e;this.stream?.getTracks().forEach(e=>{this.peer.addTrack(e,this.stream)}),this.datachannel=this.peer.createDataChannel("data"),this.datachannel.onopen=async()=>{await this.events.onConnect()},this.initiator&&(e=await this.peer.createOffer(),this.peer.setLocalDescription(e),await this.events.onSignal(e))}async onSignal(e){this.events.onSignal=e}async onIceCandidate(e){this.events.onIceCandidate=e}async addIceCandidate(e){this.peer.addIceCandidate(new RTCIceCandidate(e))}async onConnect(e){this.events.onConnect=e}async onDisconnect(e){this.events.onDisconnect=e}async onData(e){this.events.onData=e}async onStream(e){this.events.onStream=e}async signal(e){await this.peer.setRemoteDescription(e),this.initiator||(e=await this.peer.createAnswer(),this.peer.setLocalDescription(e),await this.events.onSignal(e))}async send(e){this.datachannel.send(e)}disconnect(){this.peer.close()}}export default PeerWebRTC;